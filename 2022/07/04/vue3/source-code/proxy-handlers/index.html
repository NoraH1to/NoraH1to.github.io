<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Vue3 源码阅读（3）- ProxyHandlers | 乱炖锅</title><meta name="author" content="NoraH1to"><meta name="copyright" content="NoraH1to"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="在上一节 reactive 的源码中，我们发现其向 createReactiveObject 函数传入了两个 handler： 1234567return createReactiveObject(  target,  false,  mutableHandlers,  mutableCollectionHandlers,  reactiveMap);  这两个 handler 都是 ProxyH">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3 源码阅读（3）- ProxyHandlers">
<meta property="og:url" content="https://www.norah1to.com/2022/07/04/vue3/source-code/proxy-handlers/index.html">
<meta property="og:site_name" content="乱炖锅">
<meta property="og:description" content="在上一节 reactive 的源码中，我们发现其向 createReactiveObject 函数传入了两个 handler： 1234567return createReactiveObject(  target,  false,  mutableHandlers,  mutableCollectionHandlers,  reactiveMap);  这两个 handler 都是 ProxyH">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.norah1to.com/img/cover_post.jpeg">
<meta property="article:published_time" content="2022-07-04T09:54:00.000Z">
<meta property="article:modified_time" content="2022-12-14T10:11:39.749Z">
<meta property="article:author" content="NoraH1to">
<meta property="article:tag" content="Vue3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.norah1to.com/img/cover_post.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.norah1to.com/2022/07/04/vue3/source-code/proxy-handlers/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"XO6UXN6VA1","apiKey":"9703dc8945858f7b3cb5c9ab16b2c9f0","indexName":"norah1to","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: NoraH1to","link":"链接: ","source":"来源: 乱炖锅","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue3 源码阅读（3）- ProxyHandlers',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-14 18:11:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover_post.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">乱炖锅</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue3 源码阅读（3）- ProxyHandlers</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-04T09:54:00.000Z" title="发表于 2022-07-04 17:54:00">2022-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-14T10:11:39.749Z" title="更新于 2022-12-14 18:11:39">2022-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/Vue3/">Vue3</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/Vue3/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="Vue3 源码阅读（3）- ProxyHandlers"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一节 <code>reactive</code> 的源码中，我们发现其向 <code>createReactiveObject</code> 函数传入了两个 <code>handler</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">  target,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  mutableHandlers,</span><br><span class="line">  mutableCollectionHandlers,</span><br><span class="line">  reactiveMap</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这两个 <code>handler</code> 都是 <code>ProxyHandler</code> 类型，会根据上一节解释过的 <code>TargetType</code> 传给 <code>Proxy</code> 构造函数作为第三个实参：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  target,</span><br><span class="line">  targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>mutableHandlers</code> 和 <code>mutableCollectionHandlers</code> 分别为 <code>baseHandlers.ts</code>,<code>collectionHandlers.ts</code> 暴露的主要监听器</p>
<h1 id="baseHandlers"><a href="#baseHandlers" class="headerlink" title="baseHandlers"></a>baseHandlers</h1><p>该文件中的 <code>handler</code> 用于处理 <code>Object</code>, <code>Array</code> 的代理对象</p>
<h2 id="mutableHandlers"><a href="#mutableHandlers" class="headerlink" title="mutableHandlers"></a>mutableHandlers</h2><p>是最主要的实现，上一节 <code>reactive</code> 接口的传参之一，我们直接跳到其源码处来解读：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>vue3</code> 的响应式系统监听了</p>
<ul>
<li><p>赋值</p>
</li>
<li><p>取值</p>
</li>
<li><p>删除属性</p>
</li>
<li><p>判断属性存在</p>
</li>
<li><p>获得对象上存在的属性列表</p>
</li>
</ul>
<p>这 5 种行为</p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>跳转倒 <code>get</code> 的实现，发现是一个工厂方法返回的函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> get = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>();</span><br></pre></td></tr></table></figure>

<p>其它的 <code>Getter</code> 也都是这个工厂方法构造的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> get = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>();</span><br><span class="line"><span class="keyword">const</span> shallowGet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> readonlyGet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> shallowReadonlyGet = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createGetter</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>再追踪下 <code>createGetter</code> 方法的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其接收两个参数，表示该响应式对象是否<strong>只读</strong>或是<strong>浅层的响应式</strong>（只有第一层属性是响应式的），默认都是 <code>false</code></p>
<p>方法返回了 <code>get</code> 函数，用于监听对象的<strong>取值</strong>行为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: Target,</span></span><br><span class="line"><span class="params">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">    receiver: <span class="built_in">object</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着来看 <code>get</code> 的实现</p>
<p>首先是对 <code>vue</code> 内部使用的一些 <code>flag</code> 进行特殊处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !isReadonly;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> isReadonly;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shallow;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;</span><br><span class="line">  receiver ===</span><br><span class="line">    (isReadonly</span><br><span class="line">      ? shallow</span><br><span class="line">        ? shallowReadonlyMap</span><br><span class="line">        : readonlyMap</span><br><span class="line">      : shallow</span><br><span class="line">      ? shallowReactiveMap</span><br><span class="line">      : reactiveMap</span><br><span class="line">    ).<span class="title function_">get</span>(target)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReactiveFlags.RAW</code> 这边存的是原始对象，取原始对象的时候通过对应方法的 <code>Map</code> 来获得其响应式代理对象（上一节 <code>reactive</code> 方法使用的是 <code>reactiveMap</code>，<code>readonly</code> 使用 <code>readonlyMap</code>，其它方法以此类推）</p>
<p>代理对象若存在且与当前代理对象相同，说明该对象已经被 <code>proxyHandler</code> 种的方法处理过，直接返回其原对象</p>
<p>然后判断为 <code>Array</code> 数组类型的情况：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为数组且不为只读，并且读取的是 <code>vue</code> 响应式系统需要特殊处理的方法，返回 <code>vue</code> 对这些方法的二次封装，详情请看<a href="#createarrayinstrumentations">下一小节</a></p>
<p>最后直接取值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br></pre></td></tr></table></figure>

<p>判断一些特殊情况：</p>
<ul>
<li><p><code>key</code> 为 <code>Symbol</code> 类型，并且是 <code>Symbol</code> 内置的属性；或为不能追踪的属性，直接返回值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性不是只读的，追踪该属性变动（响应式，后续在 <code>effect</code> 详细说）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是浅层响应式，直接返回值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是 <code>ref</code> 类型的属性，如果不是取数组上的元素，解包返回 <code>value</code>，否则返回值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">  <span class="comment">// ref unwrapping - skip unwrap for Array + integer key.</span></span><br><span class="line">  <span class="keyword">return</span> targetIsArray &amp;&amp; <span class="title function_">isIntegerKey</span>(key) ? res : res.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组上的 <code>ref</code> 元素不解包是为了防止原生的数组方法出现问题，例如 <code>reserve</code>，当然也可以通过复写方法来实现，但是会非常复杂（太多了），参考该 <a target="_blank" rel="noopener" href="https://github.com/vuejs/core/commit/775a7c2b414ca44d4684badb29e8e80ff6b5d3dd">commit</a>，里面提到的 issue 有例子</p>
</blockquote>
<p>目前代码会是这个效果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)]);</span><br><span class="line"><span class="comment">// 需要手动在 value 上获取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>].<span class="property">value</span>.<span class="property">count</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="title function_">ref</span>(<span class="number">0</span>) &#125;);</span><br><span class="line"><span class="comment">// 自动解包</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到这里可以断定该属性上的值没有被响应式系统处理过，判断是否为对象，进一步处理</p>
<p>如果为对象，根据该属性是否只读，让响应式系统处理该值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">  <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">  <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">  <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">  <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出 <code>vue</code> 不会一次性把所有值都在响应式系统中处理，嵌套的值只在首次使用后处理，这样性能会很好</p>
</li>
<li><p>最后，不为对象直接返回值本身</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code> 方法同上，也是一个工厂方法返回的函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="comment">/*#__PURE__*/</span> <span class="title function_">createSetter</span>();</span><br></pre></td></tr></table></figure>

<p>追踪下 <code>createSetter</code> 方法的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收一个参数，判断是否是<strong>浅层的响应式</strong>，默认 <code>false</code></p>
<p>方法返回了 <code>set</code> 函数，用于监听对象的<strong>赋值</strong>行为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">  value: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  receiver: <span class="built_in">object</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先取到旧值 <code>oldValue</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key];</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着判断旧值为<strong>只读</strong>且<strong>为 <code>ref</code></strong> 时，新值是否<strong>也为 <code>ref</code></strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是，直接返回 <code>false</code>，赋值失败</p>
</li>
<li><p>处理<strong>不为浅层属性</strong>且<strong>新值不为只读</strong>的情况</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!shallow &amp;&amp; !<span class="title function_">isReadonly</span>(value)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isShallow</span>(value)) &#123;</span><br><span class="line">    value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">    oldValue = <span class="title function_">toRaw</span>(oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">    oldValue.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果同时新值还不为浅层响应式对象，则要考虑为响应式代理对象的情况，需确保值原始对象或者普通的值</li>
</ul>
<p>为什么旧值新值都需要 <code>toRaw</code> 转换成原始对象呢？</p>
<p><strong>因为</strong></p>
<blockquote>
<p>在响应式框架中，原始对象上的属性都应当为原始对象或者普通的值，而不能为代理对象（应该是一种设计约定，不处理理论上不会有什么问题）</p>
</blockquote>
<p>获得响应式对象的属性时，应从其 <code>get</code> 监听器中从对应的 <code>proxyMap</code> 中获得值，在 <code>createGetter</code> 最后的一段代码中就是这样处理的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">  <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">  <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">  <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">  <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的两个方法都会根据原始对象的地址去<strong>获得已有的响应式对象</strong>，<strong>没有则新建</strong></p>
<p><strong>所以</strong></p>
<p>为了维护这个设计约定</p>
<p>旧值 <code>toRaw</code> 是为了处理默认值为嵌套响应式对象的情况例如 <code>const obj = reactive(&#123; value: reactive(&#123; value: 233 &#125;) &#125;)</code>；新值 <code>toRaw</code> 为了确保后续不会出现嵌套的情况</p>
<p><code>shallow = true</code> 时无需确保，因为这时属性上的值不会在 <code>get</code> 监听器中被改为响应式对象</p>
<ul>
<li>如果原始对象不为数组且为 <code>ref</code>，并且新值不为 <code>ref</code>时</li>
</ul>
<p>直接给旧值 <code>ref</code> 的 <code>value</code> 赋予新值</p>
</li>
<li><p>最后判断是更新还是新属性值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hadKey =</span><br><span class="line">  <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">    ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span></span><br><span class="line">    : <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line"><span class="comment">// don&#x27;t trigger if target is something up in the prototype chain of original</span></span><br><span class="line"><span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>给原始对象赋值</p>
<p>然后这个判断 <code>target === toRaw(receiver)</code>，个人推测是单纯的防御性代码，因为理论上不会出现不相等的情况</p>
<p>接着如果没有值，则触发<strong>增加</strong>操作，有值则触发<strong>赋值</strong>操作</p>
<p>最后返回赋值结果</p>
</li>
</ul>
<h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h2><p>监听删除属性的行为，类似下面代码就会触发：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">value</span>; <span class="comment">// 触发</span></span><br></pre></td></tr></table></figure>

<p>删除倒是最简单的，我们直接跳到其实现处：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">  <span class="keyword">const</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key];</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>, key, <span class="literal">undefined</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接删除，如果删除成且该原本是存在的，则触发 <code>DELETE</code> 的响应式操作，最后返回结果</p>
<h2 id="has"><a href="#has" class="headerlink" title="has"></a>has</h2><p><code>has</code> 用来捕捉 <code>in</code> 运算符</p>
<p>只读和浅响应式都无需在使用 <code>in</code> 时进行一些操作，所以实现也是相当简单：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isSymbol</span>(key) || !builtInSymbols.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是 <code>get</code> 中的一部分操作，取过值后的跟踪变化操作，并且也要注意不能追踪 <code>Symbol</code> 和 <code>Symbol</code> 上 <code>Symbol</code> 类型的属性</p>
<h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h2><p>这个方法会捕获获得对象上属性名列表和 <code>Symbol</code> 属性列表的方法 <code>Object.getOwnPropertyNames</code>,<code>Object.getOwnPropertySymbols</code></p>
<p>并且在使用 <code>for ... in</code> 操作符的时候也会捕获到</p>
<p>代码实现如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: <span class="built_in">object</span></span>): (<span class="built_in">string</span> | <span class="built_in">symbol</span>)[] &#123;</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="title function_">isArray</span>(target) ? <span class="string">&#x27;length&#x27;</span> : <span class="variable constant_">ITERATE_KEY</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边 <code>ITERATE_KEY</code> 的作用是标记该追踪为迭代器类型，一般是在代码或者 <code>SFC</code> 模板语法中的 <code>v-for</code> 写法中用到，又或者是 <code>computed</code> 和 <code>watchEffect</code> 中进行 <code>for ... in</code> 操作时也会用到该标记</p>
<p>在触发 <code>ADD</code>,<code>DELETE</code>,<code>SET</code> 等操作时，都会调用该标记中追踪的内容</p>
<p>至于为什么要特殊处理数组的 <code>for ... in</code> 操作去追踪 <code>length</code>，是因为在<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/issues/2427">issue</a>中，提到了 <code>computed</code> 中进行 <code>for ... in</code> 操作空数组会不更新视图，但是我个人点进去 <code>codepen</code> 并没复现出来…</p>
<h2 id="createArrayInstrumentations"><a href="#createArrayInstrumentations" class="headerlink" title="createArrayInstrumentations"></a>createArrayInstrumentations</h2><p>该方法代理了部分可能需要触发响应式操作的数组方法</p>
<p>首先声明一个对象用于存储代理方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">instrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="需监听数组元素变化"><a href="#需监听数组元素变化" class="headerlink" title="需监听数组元素变化"></a>需监听数组元素变化</h3><p>然后复写一组需要监听数组元素响应式变化的方法，分别是 <code>includes</code>, <code>indexOf</code>, <code>lastIndexOf</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instrument identity-sensitive Array methods to account for possible reactive</span></span><br><span class="line"><span class="comment">// values</span></span><br><span class="line">([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// we run the method using the original args first (which may be reactive)</span></span><br><span class="line">    <span class="keyword">const</span> res = arr[key](...args);</span><br><span class="line">    <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// if that didn&#x27;t work, run it again using raw values.</span></span><br><span class="line">      <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>来一行行看</p>
<ul>
<li><p>首先我们需要在原始对象上操作：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们仍然在 <code>this</code> 上操作的话会陷入死循环，大家稍微想下就明白了</p>
</li>
<li><p>接着追踪数组上的每一个元素的 <code>GET</code> 操作：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">  <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很重要，大家可以去掉该循环，然后跑一下测试用例（<code>pnpm test</code>），然后会发现</p>
<p>在 <code>reactivity/__tests__/reactiveArray.spec.ts</code> 下第 <code>78</code> 行的测试用例会报错：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;Array identity methods should be reactive&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="title function_">reactive</span>([obj, &#123;&#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">index</span>: <span class="built_in">number</span> = -<span class="number">1</span>;</span><br><span class="line">  <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    index = arr.<span class="title function_">indexOf</span>(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">expect</span>(index).<span class="title function_">toBe</span>(<span class="number">0</span>);</span><br><span class="line">  arr.<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="title function_">expect</span>(index).<span class="title function_">toBe</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>预期行为是 <code>effect</code> 先执行一次，在 <code>reverse</code> 执行后再执行一次</p>
<p>若 <code>indexOf</code> 没有追踪元素变化，则 <code>effect</code> 不会执行，导致最后一句断言抛错</p>
</li>
<li><p>接着就是执行方法本身</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = arr[key](...args);</span><br><span class="line"><span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// if that didn&#x27;t work, run it again using raw values.</span></span><br><span class="line">  <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保方法正确判断，这边在执行结果为 <code>false</code>, <code>-1</code> 时，在确保参数为原始对象后，会再次调用</p>
<p>例如下面这种情况：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = reactive&lt;<span class="built_in">any</span>[]&gt;([&#123;&#125;, &#123;&#125;]);</span><br><span class="line">arr.<span class="title function_">indexOf</span>(arr[<span class="number">0</span>]); <span class="comment">// 正常应该返回 0，如果上面的代码没有额外处理，会返回 -1</span></span><br></pre></td></tr></table></figure>

<p>这边因为响应式系统的原因，<code>arr[0]</code> 拿到的是一个经过响应式系统处理过的 <code>Proxy</code> 对象，那么在原始 <code>arr</code> 的原始数组上找肯定找不到，会返回 <code>-1</code>，这种行为是错误的</p>
</li>
</ul>
<h3 id="会影响数组长度的函数"><a href="#会影响数组长度的函数" class="headerlink" title="会影响数组长度的函数"></a>会影响数组长度的函数</h3><p>然后是会影响数组长度（会修改数组本身）的函数，有 <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instrument length-altering mutation methods to avoid length being tracked</span></span><br><span class="line"><span class="comment">// which leads to infinite loops in some cases (#2137)</span></span><br><span class="line">([<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">    <span class="title function_">pauseTracking</span>();</span><br><span class="line">    <span class="keyword">const</span> res = (<span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> <span class="built_in">any</span>)[key].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="title function_">resetTracking</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这边主要是为了处理死循环的问题，这个<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/issues/2137">issue</a>中说的很清楚，是 <code>3.0.0-rc.12</code> 早期版本的问题</p>
<p>复现代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台会不停的输出 <code>1</code> 和 <code>2</code></p>
<p>但是数组 <code>length</code> 属性又不能不监听，不监听会丢失很多响应性，所以这边处理方法很粗暴：在这些方法<strong>执行前暂停追踪</strong>，<strong>执行后恢复</strong>…</p>
<p>最后返回代理方法的集合</p>
<h2 id="其它-handlers"><a href="#其它-handlers" class="headerlink" title="其它 handlers"></a>其它 handlers</h2><p>例如 <code>readonly</code>, <code>shallow</code>, <code>shallowReadonly</code> 等等，无非就是限制一些行为</p>
<p>比如 <code>readonly</code> 的 <code>set</code>, <code>deleteProperty</code> 都改为空的实现，<code>get</code> 则只是 <code>createGetter</code> 工厂方法的传参不同罢了</p>
<h1 id="collectionHandlers"><a href="#collectionHandlers" class="headerlink" title="collectionHandlers"></a>collectionHandlers</h1><p>该文件中的 <code>handler</code> 用于处理 <code>Map</code>, <code>Set</code>, <code>WeakMap</code>, <code>WeakSet</code> 这类 ES 标准里合集数据结构的代理对象</p>
<p>这类数据对象都是<strong>通过自身的方法操作数据</strong>，代理对象只需要在 <code>get</code> 监听器中分发需要处理的方法即可</p>
<h2 id="mutableCollectionHandlers"><a href="#mutableCollectionHandlers" class="headerlink" title="mutableCollectionHandlers"></a>mutableCollectionHandlers</h2><p>上一节 <code>reactive</code> 接口的传参之一，我们直接跳到其源码处来解读：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableCollectionHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="title class_">CollectionTypes</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> <span class="title function_">createInstrumentationGetter</span>(<span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正如上面说的，只监听了 <code>get</code> 行为</p>
<p><code>createInstrumentationGetter</code> 是一个工厂方法，用于构建<strong>被代理的方法</strong>（e.g. <code>map.get</code>,<code>set.add</code>）</p>
<h2 id="createInstrumentationGetter"><a href="#createInstrumentationGetter" class="headerlink" title="createInstrumentationGetter"></a>createInstrumentationGetter</h2><p>该方法接收两个参数 <code>isReadonly</code>, <code>shallow</code> 分别表示是否只读和是否浅层响应：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createInstrumentationGetter</span>(<span class="params">isReadonly: <span class="built_in">boolean</span>, shallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看里面的实现：</p>
<ul>
<li><p>首先根据传参决定用方法的哪种代理实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instrumentations = shallow</span><br><span class="line">  ? isReadonly</span><br><span class="line">    ? shallowReadonlyInstrumentations</span><br><span class="line">    : shallowInstrumentations</span><br><span class="line">  : isReadonly</span><br><span class="line">  ? readonlyInstrumentations</span><br><span class="line">  : mutableInstrumentations;</span><br></pre></td></tr></table></figure>

<p>都为 <code>false</code> 时会取到 <a href="#mutableInstrumentations"><code>mutableInstrumentations</code></a></p>
</li>
<li><p>接着返回 <code>get</code> 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: CollectionTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  receiver: CollectionTypes</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>再看看该 <code>get</code> 方法的实现：</p>
<ul>
<li><p>首先处理取各种 flag 的情况：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !isReadonly;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> isReadonly;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没啥好说的，跟 <code>baseHandlers</code>里逻辑一致</p>
<p>但是这里取 <code>RAW</code> 时的逻辑不一致，导致一些行为上的差异，开了个<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/issues/6268">issue</a></p>
</li>
<li><p>然后判断是否需要代理其属性，返回</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(</span><br><span class="line">  <span class="title function_">hasOwn</span>(instrumentations, key) &amp;&amp; key <span class="keyword">in</span> target ? instrumentations : target,</span><br><span class="line">  key,</span><br><span class="line">  receiver</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="createInstrumentations"><a href="#createInstrumentations" class="headerlink" title="createInstrumentations"></a>createInstrumentations</h2><p>重点来了家人们</p>
<p>该方法构建了方法不同种类的代理实现</p>
<p>具体有这些：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [</span><br><span class="line">  mutableInstrumentations, <span class="comment">// reactive</span></span><br><span class="line">  readonlyInstrumentations, <span class="comment">// readonly</span></span><br><span class="line">  shallowInstrumentations, <span class="comment">// shallow</span></span><br><span class="line">  shallowReadonlyInstrumentations, <span class="comment">// shallowReadonly</span></span><br><span class="line">] = <span class="comment">/* #__PURE__*/</span> <span class="title function_">createInstrumentations</span>();</span><br></pre></td></tr></table></figure>

<h2 id="mutableInstrumentations"><a href="#mutableInstrumentations" class="headerlink" title="mutableInstrumentations"></a>mutableInstrumentations</h2><p>直接看最核心的 <code>mutableInstrumentations</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">mutableInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  has,</span><br><span class="line">  add,</span><br><span class="line">  set,</span><br><span class="line">  <span class="attr">delete</span>: deleteEntry,</span><br><span class="line">  clear,</span><br><span class="line">  <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代理了一大堆方法，来一个个看</p>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>很多人可能会问，下面这个 <code>this</code> 哪来的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这是一个 typescript 的特性，为<strong>第一个参数</strong>、且<strong>参数名为 <code>this</code></strong> 的类型定义，用来定义<strong>当前函数执行上下文中 <code>this</code> 的类型</strong>，并不是外部的形参</p>
<p><code>vue</code> 中挺多地方使用了 <code>this</code> 但没有检查，所以我们使用 collection 类型的响应式对象时，切记不要下面的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line"><span class="keyword">const</span> getTemp = map.<span class="property">get</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; get &#125; = map;</span><br><span class="line"><span class="title function_">getTemp</span>(<span class="number">1</span>); <span class="comment">// 会报错</span></span><br><span class="line"><span class="title function_">get</span>(<span class="number">1</span>); <span class="comment">// 也会报错</span></span><br></pre></td></tr></table></figure>

<p>下面来看返回的 <code>get</code> 方法的实现，方法接收<strong>四个</strong>参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: MapTypes,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  isReadonly = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  isShallow = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意 <code>target</code> 指的<strong>是响应式对象</strong>，而<strong>不是原始对象</strong>，因为外面传的是 <code>this</code></p>
<p>接着来看实现：</p>
<ul>
<li><p>获得一些原始的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line"><span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br><span class="line"><span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key);</span><br></pre></td></tr></table></figure>

<p>这边把 <code>target</code> 设为了其原始对象</p>
<p>然后又获得了其最深层的原始对象（用于处理 <code>readonly</code>, <code>reactive</code> 套娃的情况）</p>
<p>最后获得了其 <code>key</code> 的原始值（因为 <code>Map</code>,<code>Set</code> 的 <code>key</code> 可以是<strong>引用类型</strong>，可能是<strong>响应式</strong>的）</p>
</li>
<li><p>追踪响应式变化：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, rawKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只读就不用追踪</p>
<p>如果 <code>key</code> 不等于 <code>rawKey</code>，说明 <code>key</code> 为响应式的，所以要追踪 <code>key</code> 的变化</p>
<p>最后追踪 <code>rawKey</code> 本身的变化</p>
<p>这样做是为了用原始对象传参和响应式对象传参的行为都一致：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> reactObj = <span class="title function_">reactive</span>(originObj);</span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">map.<span class="title function_">set</span>(originObj, <span class="number">233</span>);</span><br><span class="line">map.<span class="title function_">get</span>(reactObj); <span class="comment">// 233</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把取到的值也加进响应式系统中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; has &#125; = <span class="title function_">getProto</span>(rawTarget);</span><br><span class="line"><span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><br><span class="line"><span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, key)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(key));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, rawKey)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(rawKey));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target !== rawTarget) &#123;</span><br><span class="line">  <span class="comment">// #3602 readonly(reactive(Map))</span></span><br><span class="line">  <span class="comment">// ensure that the nested reactive `Map` can do tracking for itself</span></span><br><span class="line">  target.<span class="title function_">get</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先选好处理值的处理器 <code>wrap</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><br></pre></td></tr></table></figure>

<p>然后判断在原始对象上是否有该 <code>key</code> 或者 <code>rawKey</code>，有的话就在 <code>target</code> 上调用 <code>get</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, key)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(key));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, rawKey)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(rawKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么是 <code>target.get</code> 而不是 <code>rawTarget.get</code> 呢？</p>
<p>因为如果是 <code>readonly(reactive())</code> 套娃的情况，调用 <code>rawTarget.get</code> 并不能经过里面那一层 <code>get</code> 的代理，也就是说<strong>不会执行 <code>track</code> 追踪</strong>，它会失去响应性</p>
<p>那最后为啥还要处理套娃的情况？：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target !== rawTarget) &#123;</span><br><span class="line">  <span class="comment">// #3602 readonly(reactive(Map))</span></span><br><span class="line">  <span class="comment">// ensure that the nested reactive `Map` can do tracking for itself</span></span><br><span class="line">  target.<span class="title function_">get</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要通过 <code>target.get</code> 手动追踪一下该 <code>key</code> 上值的变动？上面不是已经有处理了吗！</p>
<p>那是因为前面都是在<strong>有值</strong>的前提下处理的：<code>if(has.call(rawRTarget, key))</code>，如果<strong>没有值</strong>呢？例如下面的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>()); <span class="comment">// 为空</span></span><br><span class="line"><span class="keyword">const</span> readonlyMap = <span class="title function_">readonly</span>(map);</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> readonlyMap.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 该副作用应当在 1 上的值变动时调用</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 如果上面的代码去掉，这里 get 后副作用并不会执行</span></span><br></pre></td></tr></table></figure>

<p>这里我也是去掉部分代码后跑<strong>测试用例</strong>发现的</p>
<p>测试用例作用不仅是测试，更是<strong>方便大家学习</strong>的好东西（这点 vue 做的很好，糟糕的用例甚至会起到误导作用）</p>
</li>
</ul>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>这边代理了 <code>size</code> 的 <code>getter</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下返回的 <code>size</code> 方法的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">target: IterableCollections, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line">  !isReadonly &amp;&amp; <span class="title function_">track</span>(<span class="title function_">toRaw</span>(target), <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&#x27;size&#x27;</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单</p>
<p>先获得原始对象，若不是只读则追踪迭代操作，最后返回 <code>size</code> 的值</p>
<h3 id="has-1"><a href="#has-1" class="headerlink" title="has"></a>has</h3><p><code>has</code> 方法是 <code>Map</code> 用来判断是否存在 <code>key</code>，或者 <code>Set</code> 用来判断是否存在 <code>value</code> 的方法，方法接收<strong>两个</strong>参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: CollectionTypes,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  isReadonly = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别是 <code>key</code> 和 <code>isReadonly</code>，<code>this</code> 前面解释过</p>
<p>来看实现</p>
<ul>
<li><p>首先获得一些原始对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = (<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line"><span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br><span class="line"><span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key);</span><br></pre></td></tr></table></figure>
</li>
<li><p>追踪响应式变化：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, rawKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟前面 <code>get</code> 的实现完全一样</p>
</li>
<li><p>返回值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> key === rawKey</span><br><span class="line">  ? target.<span class="title function_">has</span>(key)</span><br><span class="line">  : target.<span class="title function_">has</span>(key) || target.<span class="title function_">has</span>(rawKey);</span><br></pre></td></tr></table></figure>

<p>判断 <code>key</code> 和 <code>rawKey</code> 是否相同，<strong>相同</strong>直接返回值，<strong>否则</strong>返回两键查找的或运算结果</p>
<p>这样做是为了用原始对象的键和其响应式代理对象查找的结果都一致：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line"><span class="keyword">const</span> origin = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> reactiveOrigin = <span class="title function_">reactive</span>(origin);</span><br><span class="line">map.<span class="title function_">set</span>(reactiveOrigin, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">has</span>(reactiveOrigin); <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">has</span>(origin); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>该方法只在 <code>Set</code> 上有，用于往集合中增加元素，并且只会在不是只读的响应式对象上存在，所以只接收<strong>一个</strong>参数 <code>value</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="variable language_">this</span>: SetTypes, value: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看实现，非常简单</p>
<ul>
<li><p>获得原始对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="title function_">toRaw</span>(value);</span><br><span class="line"><span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否已有该值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = <span class="title function_">getProto</span>(target);</span><br><span class="line"><span class="keyword">const</span> hadKey = proto.<span class="property">has</span>.<span class="title function_">call</span>(target, value);</span><br><span class="line"><span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">  target.<span class="title function_">add</span>(value);</span><br><span class="line">  <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, value, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure>

<p><strong>没有</strong>则添加，并触发 <code>ADD</code> 响应式事件</p>
<p>最后返回 <code>this</code> 即代理对象本身</p>
</li>
</ul>
<h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><p>用于设置值，只有 <code>Map</code> 上有，并且也是非只读才可用，所以只有<strong>两个</strong>参数 <code>key</code>, <code>value</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span>, value: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看实现</p>
<ul>
<li><p>先获得原始对象</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="title function_">toRaw</span>(value);</span><br><span class="line"><span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target);</span><br></pre></td></tr></table></figure>

<p>还有工具方法的获取</p>
</li>
<li><p>判断是否已经存在该键</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line"><span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">  key = <span class="title function_">toRaw</span>(key);</span><br><span class="line">  hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="title function_">checkIdentityKeys</span>(target, has, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若<strong>第一次判断不存在</strong>，会 <code>toRaw(key)</code> 后再查一次，确保可能存在的原始对象和响应式对象都查过</p>
</li>
<li><p>设置值并触发响应式事件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldValue = get.<span class="title function_">call</span>(target, key);</span><br><span class="line">target.<span class="title function_">set</span>(key, value);</span><br><span class="line"><span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">  <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">  <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure>

<p>先设置值</p>
<p>如果<strong>不存在该键</strong>，则触发 <code>ADD</code> 响应式事件</p>
<p>如果<strong>存在该键</strong>，则触发 <code>SET</code> 响应式事件，并且会传递旧值 <code>oldValue</code></p>
<p>最后返回 <code>this</code> 即响应式对象自身</p>
</li>
</ul>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除指定的值或键，这边 <code>delete</code> 为 <code>deleteEntry</code> 函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">delete</span>: deleteEntry</span><br></pre></td></tr></table></figure>

<p><code>deleteEntry</code> 只在非只读时使用，所以只有<strong>一个</strong>参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteEntry</span>(<span class="params"><span class="variable language_">this</span>: CollectionTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看实现</p>
<ul>
<li><p>获得原始值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target);</span><br></pre></td></tr></table></figure>

<p>顺带获得工具方法</p>
</li>
<li><p>判断是否有该键：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line"><span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">  key = <span class="title function_">toRaw</span>(key);</span><br><span class="line">  hadKey = has.<span class="title function_">call</span>(target, key);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="title function_">checkIdentityKeys</span>(target, has, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟上一小节实现一样</p>
</li>
<li><p>删除键值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldValue = get ? get.<span class="title function_">call</span>(target, key) : <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// forward the operation before queueing reactions</span></span><br><span class="line"><span class="keyword">const</span> result = target.<span class="title function_">delete</span>(key);</span><br><span class="line"><span class="keyword">if</span> (hadKey) &#123;</span><br><span class="line">  <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>, key, <span class="literal">undefined</span>, oldValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>先删除键值</p>
<p><strong>若该键存在</strong>则触发 <code>DELETE</code> 响应式操作</p>
<p>最后返回删除结果</p>
</li>
</ul>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>用于清空所有元素，非只读时能使用，<strong>没有参数</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"><span class="variable language_">this</span>: IterableCollections</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看实现</p>
<ul>
<li><p>获得原始对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="keyword">const</span> hadItems = target.<span class="property">size</span> !== <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>顺便记录是否有元素存在</p>
</li>
<li><p>记录旧对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldTarget = __DEV__</span><br><span class="line">  ? <span class="title function_">isMap</span>(target)</span><br><span class="line">    ? <span class="keyword">new</span> <span class="title class_">Map</span>(target)</span><br><span class="line">    : <span class="keyword">new</span> <span class="title class_">Set</span>(target)</span><br><span class="line">  : <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<p>这些代码纯粹为了开发环境调试服务</p>
</li>
<li><p>最后执行清理方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forward the operation before queueing reactions</span></span><br><span class="line"><span class="keyword">const</span> result = target.<span class="title function_">clear</span>();</span><br><span class="line"><span class="keyword">if</span> (hadItems) &#123;</span><br><span class="line">  <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, oldTarget);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>先执行清理</p>
<p>然后判断原本是否有元素，如果有则触发 <code>CLEAR</code> 响应式操作</p>
<p>最后返回清理结果</p>
</li>
</ul>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>遍历元素的方法，这种读操作的方法基本跟上面 <code>get</code> 逻辑差不多，由 <code>createForEach</code> 工厂方法构建：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><code>createForEach</code> 接收<strong>两个参数</strong>，分别是 <code>isReadonly</code>, <code>isShallow</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createForEach</span>(<span class="params">isReadonly: <span class="built_in">boolean</span>, isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部返回了一个 <code>forEach</code> 函数，接收<strong>两个参数</strong>，<code>callback</code> 和 <code>thisArg</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">forEach</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: IterableCollections,</span></span><br><span class="line"><span class="params">  callback: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  thisArg?: <span class="built_in">unknown</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看实现：</p>
<ul>
<li><p>获得一些原始对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = <span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">const</span> target = observed[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line"><span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br></pre></td></tr></table></figure>

<p>同时记录了当前代理对象为 <code>observed</code></p>
</li>
<li><p>选好处理值的处理器 <code>wrap</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不是只读，则追踪迭代操作</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后调用 <code>forEach</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value: <span class="built_in">unknown</span>, key: <span class="built_in">unknown</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// important: make sure the callback is</span></span><br><span class="line">  <span class="comment">// 1. invoked with the reactive map as `this` and 3rd arg</span></span><br><span class="line">  <span class="comment">// 2. the value received should be a corresponding reactive/readonly.</span></span><br><span class="line">  <span class="keyword">return</span> callback.<span class="title function_">call</span>(thisArg, <span class="title function_">wrap</span>(value), <span class="title function_">wrap</span>(key), observed);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>维持 <code>forEach</code> 原来的行为即可，要把 <code>value</code> 和 <code>key</code> 经过响应式系统处理</p>
</li>
</ul>
<h2 id="createIterableMethod"><a href="#createIterableMethod" class="headerlink" title="createIterableMethod"></a>createIterableMethod</h2><p>然后我们拉到 <code>createInstrumentations</code> 实现的下面，会发现还代理了迭代器相关的方法 <code>keys</code>, <code>values</code>, <code>entries</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iteratorMethods = [<span class="string">&#x27;keys&#x27;</span>, <span class="string">&#x27;values&#x27;</span>, <span class="string">&#x27;entries&#x27;</span>, <span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line">iteratorMethods.<span class="title function_">forEach</span>(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>它把这些方法的代理方法通过 <code>createIterableMethod</code> 工厂方法构建，并添加到对应的代理合集中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutableInstrumentations[method <span class="keyword">as</span> <span class="built_in">string</span>] = <span class="title function_">createIterableMethod</span>(</span><br><span class="line">  method,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>createIterableMethod</code> 接收<strong>三个</strong>参数，<code>method</code>, <code>isReadonly</code>, <code>isShallow</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterableMethod</span>(<span class="params"></span></span><br><span class="line"><span class="params">  method: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">  isReadonly: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params">  isShallow: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回了一个代理方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: IterableCollections,</span></span><br><span class="line"><span class="params">  ...args: <span class="built_in">unknown</span>[]</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Iterable</span> &amp; <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看这个方法的实现：</p>
<ul>
<li><p>首先获得原始对象和最深层的原始对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = (<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>];</span><br><span class="line"><span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target);</span><br></pre></td></tr></table></figure>

<p>跟前面作用一致，处理 <code>readonly</code>, <code>reactive</code> 套娃的情况</p>
</li>
<li><p>判断方法的类型，和处理器类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetIsMap = <span class="title function_">isMap</span>(rawTarget);</span><br><span class="line"><span class="keyword">const</span> isPair =</span><br><span class="line">  method === <span class="string">&#x27;entries&#x27;</span> || (method === <span class="title class_">Symbol</span>.<span class="property">iterator</span> &amp;&amp; targetIsMap);</span><br><span class="line"><span class="keyword">const</span> isKeyOnly = method === <span class="string">&#x27;keys&#x27;</span> &amp;&amp; targetIsMap;</span><br><span class="line"><span class="keyword">const</span> innerIterator = target[method](...args);</span><br><span class="line"><span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><br></pre></td></tr></table></figure>

<p><code>targetIsMap</code> 判断是否为 <code>Map</code>, <code>WeakMap</code></p>
<p><code>isPair</code> 判断是否是数组类型的值，<code>entries</code> 中回调函数得到的是 <code>[key, value]</code><br>同时 <code>Map</code> 类型的迭代器（<code>map[Symbol.iterator]</code>）返回的也是 <code>entries</code></p>
<p><code>isKeyOnly</code> 判断是否仅为键值，只有 <code>Map</code> 有键，<code>Set.keys()</code> 与 <code>Set.values()</code> 返回的为同一个迭代器</p>
<p><code>innerIterator</code> 为原始对象上的迭代器</p>
<p><code>wrap</code> 根据传参决定如何把迭代器访问的值放入响应式系统，跟前面一样</p>
</li>
<li><p>不是只读，则追踪迭代器事件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!isReadonly &amp;&amp;</span><br><span class="line">  <span class="title function_">track</span>(</span><br><span class="line">    rawTarget,</span><br><span class="line">    <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>,</span><br><span class="line">    isKeyOnly ? <span class="variable constant_">MAP_KEY_ITERATE_KEY</span> : <span class="variable constant_">ITERATE_KEY</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>这里的 <code>MAP_KEY_ITERATE_KEY</code> 其实跟 <code>ITERATE_KEY</code> 在生产环境下都是空字符串，前面也有很多地方并没有处理这个东西，其实是不用处理的</p>
</li>
<li><p>最后返回一个自定义的迭代器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="comment">// iterator protocol</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// iterable protocol</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>next</code> 方法大家都知道的，下面详细说</p>
<p><code>Symbol.iterator</code> 则是为了还原原生迭代器的行为，执行会返回迭代器自身</p>
<p>其实还有个东西这边没有还原，<code>Symbol.toStringTag</code> 这个字段应当是个字符串，表示其自身的迭代器类型，具体作用看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag"><code>MDN文档</code></a></p>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值为 &quot;Set Iterator&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Set</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印 &quot;[object Set Iterator]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器 next 的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; value, done &#125; = innerIterator.<span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">return</span> done</span><br><span class="line">    ? &#123; value, done &#125;</span><br><span class="line">    : &#123;</span><br><span class="line">        <span class="attr">value</span>: isPair ? [<span class="title function_">wrap</span>(value[<span class="number">0</span>]), <span class="title function_">wrap</span>(value[<span class="number">1</span>])] : <span class="title function_">wrap</span>(value),</span><br><span class="line">        done,</span><br><span class="line">      &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从原始迭代器上获得 <code>next()</code> 的返回值</p>
<p>接着就是一连串的条件判断：</p>
<ul>
<li><p>如果迭代完成，则直接返回原始值，因为此时 <code>value</code> 必定为 <code>undefined</code></p>
</li>
<li><p>否则判断值是否为 <code>[key, value]</code> 这样的形式，返回被 <code>wrap</code> 处理后的值</p>
</li>
</ul>
</li>
</ul>
<h2 id="其它-handlers-1"><a href="#其它-handlers-1" class="headerlink" title="其它 handlers"></a>其它 handlers</h2><p>只是 <code>createInstrumentationGetter</code> 的传参不同，传参不同会使用不同的代理方法</p>
<h3 id="readonlyInstrumentations"><a href="#readonlyInstrumentations" class="headerlink" title="readonlyInstrumentations"></a>readonlyInstrumentations</h3><p>拿 <code>readonlyInstrumentations</code> 举例说下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">readonlyInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">IterableCollections</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> has.<span class="title function_">call</span>(<span class="variable language_">this</span>, key, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">add</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>),</span><br><span class="line">  <span class="attr">set</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>),</span><br><span class="line">  <span class="attr">delete</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>),</span><br><span class="line">  <span class="attr">clear</span>: <span class="title function_">createReadonlyMethod</span>(<span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>),</span><br><span class="line">  <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">true</span>, <span class="literal">false</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到都是用之前说过的工厂方法来构建，又或者是方法传参不同</p>
<p>部分不允许的操作用了 <code>createReadonlyMethod</code> 这个工厂方法</p>
<h3 id="createReadonlyMethod"><a href="#createReadonlyMethod" class="headerlink" title="createReadonlyMethod"></a>createReadonlyMethod</h3><p>这个方法实现很简单：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReadonlyMethod</span>(<span class="params"><span class="keyword">type</span>: TriggerOpTypes</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: CollectionTypes, ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = args[<span class="number">0</span>] ? <span class="string">`on key &quot;<span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>&quot; `</span> : <span class="string">``</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;capitalize(<span class="keyword">type</span>)&#125;</span> operation <span class="subst">$&#123;key&#125;</span>failed: target is readonly.`</span>,</span><br><span class="line">        <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">type</span> === <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span> ? <span class="literal">false</span> : <span class="variable language_">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是开发模式，则抛出警告，最后直接返回操作失败的返回值</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.norah1to.com">NoraH1to</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.norah1to.com/2022/07/04/vue3/source-code/proxy-handlers/">https://www.norah1to.com/2022/07/04/vue3/source-code/proxy-handlers/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.norah1to.com" target="_blank">乱炖锅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue3/">Vue3</a></div><div class="post_share"><div class="social-share" data-image="/img/cover_post.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/04/vue3/source-code/reactive/"><img class="prev-cover" src="/img/cover_post.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue3 源码阅读（2）- reactive</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/03/vue3/source-code/basic/"><img class="next-cover" src="/img/cover_post.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue3 源码阅读（1）- 前置知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/03/vue3/source-code/basic/" title="Vue3 源码阅读（1）- 前置知识"><img class="cover" src="/img/cover_post.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-03</div><div class="title">Vue3 源码阅读（1）- 前置知识</div></div></a></div><div><a href="/2022/07/25/vue3/source-code/computed/" title="Vue3 源码阅读（6）- computed"><img class="cover" src="/img/cover_post.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-25</div><div class="title">Vue3 源码阅读（6）- computed</div></div></a></div><div><a href="/2022/07/18/vue3/source-code/effect/" title="Vue3 源码阅读（4）- effect"><img class="cover" src="/img/cover_post.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-18</div><div class="title">Vue3 源码阅读（4）- effect</div></div></a></div><div><a href="/2022/11/07/vue3/tips/check-listener/" title="是否存在监听器"><img class="cover" src="/img/cover_post.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-07</div><div class="title">是否存在监听器</div></div></a></div><div><a href="/2022/07/04/vue3/source-code/reactive/" title="Vue3 源码阅读（2）- reactive"><img class="cover" src="/img/cover_post.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-04</div><div class="title">Vue3 源码阅读（2）- reactive</div></div></a></div><div><a href="/2022/07/20/vue3/source-code/ref/" title="Vue3 源码阅读（5）- ref"><img class="cover" src="/img/cover_post.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-20</div><div class="title">Vue3 源码阅读（5）- ref</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">NoraH1to</div><div class="author-info__description">以我残躯化作烈火</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/11171730/"><i class="fab fa-bilibili"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:sterbenlixuan@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://github.com/NoraH1to" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://steamcommunity.com/profiles/76561198239304782/" target="_blank" title="Steam"><i class="fa-brands fa-steam"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#baseHandlers"><span class="toc-number">1.</span> <span class="toc-text">baseHandlers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mutableHandlers"><span class="toc-number">1.1.</span> <span class="toc-text">mutableHandlers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get"><span class="toc-number">1.2.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">1.3.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deleteProperty"><span class="toc-number">1.4.</span> <span class="toc-text">deleteProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#has"><span class="toc-number">1.5.</span> <span class="toc-text">has</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ownKeys"><span class="toc-number">1.6.</span> <span class="toc-text">ownKeys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createArrayInstrumentations"><span class="toc-number">1.7.</span> <span class="toc-text">createArrayInstrumentations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%98%E5%8C%96"><span class="toc-number">1.7.1.</span> <span class="toc-text">需监听数组元素变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">会影响数组长度的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83-handlers"><span class="toc-number">1.8.</span> <span class="toc-text">其它 handlers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#collectionHandlers"><span class="toc-number">2.</span> <span class="toc-text">collectionHandlers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mutableCollectionHandlers"><span class="toc-number">2.1.</span> <span class="toc-text">mutableCollectionHandlers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createInstrumentationGetter"><span class="toc-number">2.2.</span> <span class="toc-text">createInstrumentationGetter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createInstrumentations"><span class="toc-number">2.3.</span> <span class="toc-text">createInstrumentations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutableInstrumentations"><span class="toc-number">2.4.</span> <span class="toc-text">mutableInstrumentations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size"><span class="toc-number">2.4.2.</span> <span class="toc-text">size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#has-1"><span class="toc-number">2.4.3.</span> <span class="toc-text">has</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add"><span class="toc-number">2.4.4.</span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-1"><span class="toc-number">2.4.5.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete"><span class="toc-number">2.4.6.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear"><span class="toc-number">2.4.7.</span> <span class="toc-text">clear</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">2.4.8.</span> <span class="toc-text">forEach</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createIterableMethod"><span class="toc-number">2.5.</span> <span class="toc-text">createIterableMethod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83-handlers-1"><span class="toc-number">2.6.</span> <span class="toc-text">其它 handlers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readonlyInstrumentations"><span class="toc-number">2.6.1.</span> <span class="toc-text">readonlyInstrumentations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createReadonlyMethod"><span class="toc-number">2.6.2.</span> <span class="toc-text">createReadonlyMethod</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/23/basic/javascript/new/" title="new 关键字"><img src="/img/cover_post.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="new 关键字"/></a><div class="content"><a class="title" href="/2022/11/23/basic/javascript/new/" title="new 关键字">new 关键字</a><time datetime="2022-11-23T08:05:00.000Z" title="发表于 2022-11-23 16:05:00">2022-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/19/vue3/vuetify/source-code/use-render/" title="Vuetify v3（2）- useRender"><img src="/img/cover_post.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vuetify v3（2）- useRender"/></a><div class="content"><a class="title" href="/2022/11/19/vue3/vuetify/source-code/use-render/" title="Vuetify v3（2）- useRender">Vuetify v3（2）- useRender</a><time datetime="2022-11-19T09:05:00.000Z" title="发表于 2022-11-19 17:05:00">2022-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/17/vue3/vuetify/source-code/default-props/" title="Vuetify v3（1）- defineComponent"><img src="/img/cover_post.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vuetify v3（1）- defineComponent"/></a><div class="content"><a class="title" href="/2022/11/17/vue3/vuetify/source-code/default-props/" title="Vuetify v3（1）- defineComponent">Vuetify v3（1）- defineComponent</a><time datetime="2022-11-17T08:07:00.000Z" title="发表于 2022-11-17 16:07:00">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/basic/css/fc/gfc/" title="栅格格式化上下文(GFC)"><img src="/img/cover_post.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栅格格式化上下文(GFC)"/></a><div class="content"><a class="title" href="/2022/11/16/basic/css/fc/gfc/" title="栅格格式化上下文(GFC)">栅格格式化上下文(GFC)</a><time datetime="2022-11-16T13:16:00.000Z" title="发表于 2022-11-16 21:16:00">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/basic/css/fc/ffc/" title="弹性格式化上下文(FFC)"><img src="/img/cover_post.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="弹性格式化上下文(FFC)"/></a><div class="content"><a class="title" href="/2022/11/16/basic/css/fc/ffc/" title="弹性格式化上下文(FFC)">弹性格式化上下文(FFC)</a><time datetime="2022-11-16T12:45:00.000Z" title="发表于 2022-11-16 20:45:00">2022-11-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By NoraH1to</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-1grnw2l3f5e9a363',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'blog-1grnw2l3f5e9a363',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>