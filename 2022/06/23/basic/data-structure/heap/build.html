<hr>
<p>title: 构建堆<br>
date: 2022-06-23 16:20:00<br>
authors: NoraH1to<br>
categories:</p>
<ul>
<li>[数据结构]<br>
tags:</li>
<li>堆</li>
<li>数据结构</li>
</ul>
<hr>
<h2 id="最大堆">最大堆</h2>
<p>从最后一个非叶子节点开始：</p>
<ol>
<li>
<p>和孩子节点的最大值比较</p>
</li>
<li>
<p>大于 - 不需要继续下沉</p>
</li>
<li>
<p>小于 - 和最大值交换位置，继续和下一层孩子重复 <code>1</code>,<code>2</code>,<code>3</code></p>
</li>
</ol>
<pre><code class="language-javascript">function adjustMaxHeap(array, index, length) {
  // 每次循环都从从当前节点的左孩子开始
  for (let i = 2 * index + 1; i &lt; length; i = 2 * i + 1) {
    // 如果右孩子存在且大于左孩子，指针指向右孩子
    if (i + 1 &lt; length &amp;&amp; array[i + 1] &gt; array[i]) {
      i++;
    }
    // 如果当前节点大于等于最大的孩子节点，无需替换
    if (array[index] &gt;= [array[i]]) {
      break;
    } else {
      // 否则交换两节点的值，记录节点值的新下标，继续下沉
      [array[index], array[i]] = [array[i], array[index]];
      index = i;
    }
  }
}

function createMaxHeap(arr, length) {
  // 从最后一个非叶子节点开始，向堆顶遍历处理
  for (let i = Math.floor(length / 2) - 1; i &gt;= 0; i--) {
    adjustMaxHeap(arr, i, length);
  }
  return arr;
}
</code></pre>
<h2 id="最小堆">最小堆</h2>
<p>从最后一个非叶子节点开始：</p>
<ol>
<li>
<p>和孩子节点的最小值比较</p>
</li>
<li>
<p>小于 - 不需要继续下沉</p>
</li>
<li>
<p>大于 - 和最小值交换位置，继续和下一层孩子重复 <code>1</code>,<code>2</code>,<code>3</code></p>
</li>
</ol>
<pre><code class="language-javascript">function adjustMinHeap(array, index, length) {
  // 每次循环都从从当前节点的左孩子开始
  for (let i = 2 * index + 1; i &lt; length; i = 2 * i + 1) {
    // 如果右孩子存在且小于左孩子，指针指向右孩子
    if (i + 1 &lt; length &amp;&amp; array[i + 1] &lt; array[i]) {
      i++;
    }
    // 如果当前节点小于等于最小的孩子节点，无需替换
    if (array[index] &lt; [array[i]]) {
      break;
    } else {
      // 否则交换两节点的值，记录节点值的新下标，继续下沉
      [array[index], array[i]] = [array[i], array[index]];
      index = i;
    }
  }
}

function createMinHeap(arr, length) {
  // 从最后一个非叶子节点开始，向堆顶遍历处理
  for (let i = Math.floor(length / 2) - 1; i &gt;= 0; i--) {
    adjustMinHeap(arr, i, length);
  }
  return arr;
}
</code></pre>
